---
title: The Mysterious @conn in Phoenix
description: Let's see how a @conn is processed by Phoenix and the response you see eventually on your browser.
createdAt: 2022-09-10
head.title: The Mysterious @conn in Phoenix
head.description: Let's see how a @conn is processed by Phoenix and the response you see eventually on your browser.
---

# The Mysterious @conn in Phoenix

When I started learning **Elixir** long back, I used to wonder why this **@conn** struct (there are no objects in Elixir world) is seen everywhere - _plugs_, _routes_, _controllers_, _views_ and in _templates_. In this post we will see how the **_conn_** is transformed along the way. Yes, in each step, a new **_conn_** struct is created.

To be a better Phoenix developer, this post is a must read. It's long but worth your time.

## Two Worlds

We know Elixir relies on Erlang heavily. In fact, when you create an Elixir app, it is Erlang OTP (Open Telecom Platform) app you are creating. Under the hood, Elixir talks to Erlang to process all of your requests. Let's see some of the unfamiliar members of both worlds.

![](/images/1_1.png)

### Erlang World

People living in this world speak Erlang language with their strength called _BEAM_.

**Cowboy**

It is _the_ default HTTP server for Erlang/OTP. It is similar to _Apache_ or _Nginx_. The difference is that unlike Apache and Nginx, which serve requests by mapping each HTTP request to file on the disk, _Cowboy_ maps each HTTP request to an Erlang module. It works in tandem with _Ranch_ which is a socket worker pool for TCP.

```json
// A simple Nginx configuration
server {
	 listen 80;
	 root /var/www/basicswithamit.com/public_html;
	 server_name basicswithamit.com;
}
```

```xml
<!-- A simple Apache configuration -->
<VirtualHost *:80>
  DocumentRoot "/var/www/basicswithamit.com/public_html"
  ServerName basicswithamit.com
</VirtualHost>
```

_Cowboy_ has no idea of the files on the disk. In below example, you can see, it maps every HTTP request to _MyApp.Cowbboy.Handler_ module.

```elixir
dispatch_config = :cowboy_router.compile([
    { :_,
		[
				{:_, MyApp.Cowboy.Handler, []},
		]}
])

{ :ok, _ } = :cowboy.start_http(:http,
	100,
	[{:port, 8080}],
	[{ :env, [{:dispatch, dispatch_config}]}]
	)
```

**Ranch**

Cowboy understands how to handle the HTTP protocol but it still does not know how to handle incoming socket connections and managing the TCP protocol, and for this it depends on _Ranch_ to do the work. _Ranch_ is a socket acceptor pool toolkit for TCP protocols written in Erlang. It has two main parts:

_Ranch Acceptors_: A group of processes that are actively accepting connections from external clients.

_Ranch Connections_: Once the acceptor accepts a new connection, it delegates to this process to actually begin processing the incoming requests.

### Elixir World

We, modern people who find Erlang complex to understand, just speak Elixir. This language talks to Erlang to carry out its day-to-day job.

**Plug**

It is web server interface for Elixir. It is similar to _Rack_ in the Ruby world. Plug gives us a few ready-made implementations: _CSRF protection_, _sessions_, _logging_ or serving _static files_. There are various plugs that come by default when you create a new phoenix project. Some of them are:

- MyPhoenixApp.Endpoint: The entry point of your application. Only _Conn_ can come in and go out.
- MyPhoenixApp.Router
- MyPhoenixApp.Controller
- MyPhoenixApp.View

It is most likely that you will also write a custom plug to authenticate requests.

## Phoenix

Before we understand the **@conn** in detail, let's create a Phoenix app.

When you run below command, Phoenix creates an Elixir OTP app which follows the same rules that apply to any normal OTP app.

```elixir
mix phx.new my_phoenix_app
```

When you give below command, you are creating a world of Phoenix that is ready to accept requests and give out responses. Let's see how this world begins its life.

```elixir
mix phx.server
```
