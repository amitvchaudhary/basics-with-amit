---
title: Error Handling
description: Hanlde errors in Elixir effectively
createdAt: 2023-02-20
head.title: Error Handling
head.description: Hanlde errors in Elixir effectively
---

::post-image{imageSrc="header_4.jpg"}
Error Handling
::

Long back, I was introduced to **Elixir** as a resilient and self-healing system. I wondered then how could it be. The real reason behind it is **processes**. No two processes share same state, thus when one process fails, we can spin up the new one without affecting the another. It's the **supervisor** (another process) which looks after all this stuff.

It's said that you won't find much error handling code in Elixir projects because of the self-healing concept (creating new processes). My view is that it's 70% true. In the projects where I have worked, people still handle errors with the help of `try` and `resuce`. Then isn't this contradictory to self-healing principle?

I think looking at Elixir just based on fault-tolerance would be wrong. We do need error handling code. For e.g, I have seen cases where our production environment went down because there was no such error handling code to handle errors. When I say handle errors, I mean the system should continue to operate (of course user should be informed of the error) and not show any blank white page to the user. This is true because, nowadays people do not treat Elixir just as a backend language. Due to Phoenix framework and it's **Live Components**, people have started replacing SPAs (React, Vue, Angular) with Live Components in some instances.

So where the project's frontend and backend both are in Elixir, I feel we should definetely have error handling code. If it were just API (REST or GraphQL), then atleast the API would fail and not the frontend.

Based on the above beliefs, I think you should be aware of different ways to handle errors in Elixir.

## Runtime Errors

These are the most prevalent ones. Catch them :bug: :bug: else they will bring your business down. :wink: So, let's see what these errors look like. By the way, there are three types of runtime errors:

- errors
- exits
- throws

### errors

These are something which you treat as exceptions in other languages. These are unexpected ones in your code.

```elixir
iex> :amit + 1
** (ArithmeticError) bad argument in arithmetic expression: :amit + 1
    :erlang.+(:amit, 1)
    iex:1: (file)
iex(1)>
```

```elixir
iex> SomeModule.unknown_function()
** (UndefinedFunctionError) function SomeModule.unknown_function/0 is undefined (module SomeModule is not available)
    SomeModule.unknown_function()
    iex:1: (file)
```

```elixir
iex> List.first({1,2,3})
** (FunctionClauseError) no function clause matching in List.first/2
```

Above were few examples which you may encounter in your code. But there are times when you need to raise your own exceptions. So, you can just **raise** it. :smiley:

```elixir
iex> raise "OH MY GOD! This is an error!"
** (RuntimeError) OH MY GOD! This is an error!
    iex:2: (file)
```

If you want to define the error name, you need to use `raise/2` macro.

```elixir
iex> raise ArithmeticError, message: "sorry no zeros accepted"
** (ArithmeticError) sorry no zeros accepted
    iex:2: (file)
```

You are able to raise such `ArithmeticError` error because it's built-in. But if you want to create your own exceptions, then you can define your own error modules. Yes modules and not just function.

```elixir
defmodule MyError do
    defexception message: "this is the default message"
end
```

So, let's try our custom error module.

```elixir
iex> raise MyError
** (MyError) this is the default message
    iex:3: (file)
```

In case you want to provide your custom message.

```elixir
iex> raise MyError, message: "custom message"
** (MyError) custom message
    iex:3: (file)
```

In real code, you won't use `iex` shell to `raise` exceptions. Of course, you would do it from functions defined in your code. But when you do that, ensure you follow naming conventions. If your function **raises** an error, you should end your function name with `!`. Why? Just read :point_down: topic.

::related-posts
[- Functions (Naming Conventions)](functions#naming-conventions)
::

### exit

If you are reading this post, then I assume you are somewhat familiar why Elixir (or Erlang) uses processes to achieve high concurrency. So, it's normal for a process to crash. But when it crashes, it's good that it also informs the reason why it crashed.

Here, we are are spawning a new process and letting it crash (or terminate).

```elixir
iex> spawn(fn ->
...> IO.puts("I am doing something ....")
...> exit("I am terminating myself!")
...> IO.puts("Let's see if this prints")
...> end)
I am doing something ....
#PID<0.113.0>
```

You might wonder why it didn't print the reason for exiting. Well we will see later how other process detects the process crash and fetches the exit reason.

### throw

Due to Elixir being a functional language, you might write some functions which have deep level of nesting. So, if the innermost functions wants to break for some reason (remember there are no **break**, **continue**, and **return** constructs in Elixir), you can use _throw_. Because of this, you can catch the error (or value) up the call stack.

```elixir
iex> throw(:some_value)
** (throw) :some_value
    iex:2: (file)
```

I suggest not to use this technique as hack to exit from recursions. Try to improve your code rather.

## Handle Errors

Now you know what the error lokks like. But what will you do with it? You need to take some action. But how? First you need to intercept it. So, to do that we have `try-catch` tool.

```elixir
try do
    raise "Something went wrong"
    IO.puts("It won't print.")
catch error_type, error_value ->
    IO.puts("Error\n  #{inspect(error_type)}\n  #{inspect(error_value)}")
end

Error
  :error
  %RuntimeError{message: "Something went wrong"}
```

Because you _raised_ an error, you got `:error` as a type. If you `throw` a value, you will get `:throw` error type and same is for `exit`.

```elixir
try do
    throw "Something went wrong"
    IO.puts("It won't print.")
catch error_type, error_value ->
    IO.puts("Error\n  #{inspect(error_type)}\n  #{inspect(error_value)}")
end

Error
  :throw
  %RuntimeError{message: "Something went wrong"}
```

As discussed before, `throw` is useful if you want to return a value from inside a deep nested loop and with the help of _pattern matching_, you can capture the value.

```elixir
try do
    throw({:result, some_result})
catch
    :throw, {:result, x} -> IO.puts(x)
end
```

Because `catch` is a pattern match, you can define multiple clauses.

```elixir
try do
    .... # some code
catch
    :throw, {:result, x} -> IO.puts(x)
    :exit, value -> IO.puts(value)
    :error, value -> IO.puts(value)
end
```

But in case you define any other clause except `throw`, then it will be propogated further up the call stack and needs to be handled there. If that doesn't happen, then the process will terminate. If you want to have default clause, then just use:

```elixir
try do
    .... # some code
catch
    :throw, {:result, x} -> IO.puts(x)
    :exit, value -> IO.puts(value)
    :error, value -> IO.puts(value)
    _,_ -> IO.puts("I am there, don't worry")
end
```

Similar to other languages, you might need to execute some code (e.g, famous example is to close DB connection or file) whether there is an error or not, you can use `after`.

```elixir
try do
    .... # some code
catch
    :throw, {:result, x} -> IO.puts(x)
    :exit, value -> IO.puts(value)
    :error, value -> IO.puts(value)
    _,_ -> IO.puts("I am there, don't worry!")
after
    IO.puts("I will always be called.")
end
```
