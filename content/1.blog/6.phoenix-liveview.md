---
title: "Phoenix LiveView"
description: "Phoenix LiveView"
createdAt: 2023-03-21
head.title: "Phoenix LiveView"
head.description: "Phoenix LiveView"
---

::post-image{imageSrc="header_8.jpg"}
Phoenix LiveView
::

I have been a frontend developer for long time and used all major frameworks like React, Vue, Anuglar, NextJS, Svelte, Remix, Astro, etc. When I came across Phoenix LiveView article, when it was introduced in 2018, I just skimmed the content and didn't give much time to try and test as other frontend frameworks were already capable of doing wonderful things. But in 2021, when I was building a custom chatbot with tech stack ReactJS, GraphQL, Web Socket, Python, NodeJS, Postgres, etc, I hit a performance roadblock. The real issue was concurrent connections, backend could support about 30,000 connections per second with multiple servers running on cloud. I was not happy with the overall solution. Then in 2022, I came across LiveView again and this was the time when I started learning Elixir with more interest. This time, I was already convinced that LiveView is capable of replacing all the existing SPA and SSR frameworks. At the time of writing this article, I would say NextJS/Remix/Astro all are trying to get best of both SPA (Single Page Application) and SSR (Server Side Rendering) worlds with hybrid approach. I personally like _island architecture_ in Astro where you can populate portions of the UI dynamically. Still, even frameworks like Astro can't compete with LiveView, that's what I believe, because the amount of data you _send_ from server to client **matters**.

Let's see how LiveView utilizes socket connection and sends minimal data to client.

## The Problem

The common issue with SSR (think of PHP days) is that even for small change in the UI, it sends whole page to the client. This didn't provide good user experience as user had to wait for few seconds after making any change - even clicking a button. To solve this, people started using SPA frameworks and took advantage of AJAX, where client would send an AJAX request to server and server will respond with JSON data. This indeed provided a good user experience but then the applications started taking more time to load the initial data. Imagine waiting for login page to appear after 7-8 seconds because the application size increased as most of the business logic moved to frontend. To overcome this, people started using build tools like Webpack, Vite, etc to build chunks of the application and load them when needed (importing components dynamically). Though this solved some of the performance issues and improved initial loading time, the application is now more dependent on JavaScript. What if you disable JavaScript in your browser? By the way, no one does this in reality.

![](/images/6_1.png){m-auto}

In the above image, to change a portion of the page, you send an HTTP (REST or GraphQL) request and manage the JSON reponse on the frontend. It might be possible that you store that response in local storage or use some store management solution (Redux, Pinia, etc). For better user experience, you update that local object and send the changes (after few seconds) to server to make the changes in the database. This is how you sync the state between frontend and backend. Imagine backend could not perform the database operation and you showed some optimistic message to the user assuming backend will not fail. Once the user refreshes the page, he is shown old state stored in database. This is one of the **real** problems.

It is not just limited to technology, but also developer experience. In a mid-size project, you often have different frontend and backend technologies. Thus you have different teams with different skill sets. Backend developer just focuses on implementing business use cases and cares only about JSON request and response. Frontend developer plays with styling, component libraries, state management, HTTP/GraphQL, cookies, security, etc. There are times where you even need to include multiple frameworks in the frontend to serve some speicific needs (Astro - Island Architecture :smiley:). Even to design a small component, frontend and backend developers need to sit and discuss the API parameters before writing the code. The classes (Object Oriented) in the backend and frotend start looking similar. More duplicacy. Even when one property in a backend class changes, related changes need to be made in frontend as well. Technically they are separate, but they are tightly coupled. Ultimately, different worlds with different technologies, taking the project cost up and chances of technical debt high. Trust me, managing multi-language system is challenging.

Elixir with Phoenix LiveView can streamline your team, can help you reduce your cost and improve the performace. To just realize this one line, you need to know Elixir and LiveView both very well. In this article we will see how server communicates with browser client.

![](/images/6_2.png){m-auto}

![](/images/6_3.png){m-auto}

![](/images/6_4.png){m-auto}
