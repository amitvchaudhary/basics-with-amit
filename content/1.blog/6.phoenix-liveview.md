---
title: "Phoenix LiveView"
description: "Phoenix LiveView"
createdAt: 2023-03-21
head.title: "Phoenix LiveView"
head.description: "Phoenix LiveView"
---

::post-image{imageSrc="header_8.jpg"}
Phoenix LiveView
::

I have been a frontend developer for long time and used all major frameworks like React, Vue, Anuglar, NextJS, Svelte, Remix, Astro, etc. When I came across Phoenix LiveView article, when it was introduced in 2018, I just skimmed the content and didn't give much time to try and test as other frontend frameworks were already capable of doing wonderful things. But in 2021, when I was building a custom chatbot with tech stack ReactJS, GraphQL, Web Socket, Python, NodeJS, Postgres, etc, I hit a performance roadblock. The real issue was concurrent connections, backend could support about 30,000 connections per second with multiple servers running on cloud. I was not happy with the overall solution. Then in 2022, I came across LiveView again and this was the time when I started learning Elixir with more interest. This time, I was already convinced that LiveView is capable of replacing all the existing SPA and SSR frameworks. At the time of writing this article, I would say NextJS/Remix/Astro all are trying to get best of both SPA (Single Page Application) and SSR (Server Side Rendering) worlds with hybrid approach. I personally like _island architecture_ in Astro where you can populate portions of the UI dynamically. Still, even frameworks like Astro can't compete with LiveView, that's what I believe, because the amount of data you _send_ from server to client **matters**.

Let's see how LiveView utilizes socket connection and sends minimal data to client.

## The Problem

The common issue with SSR (think of PHP days) is that even for small change in the UI, it sends whole page to the client. This didn't provide good user experience as user had to wait for few seconds after making any change - even clicking a button.

![](/images/6_2.png){m-auto}

To solve this, people started using SPA frameworks and took advantage of AJAX, where client would send an AJAX request to server and server will respond with JSON data. This indeed provided a good user experience but then the applications started taking more time to load the initial data. Imagine waiting for login page to appear after 7-8 seconds because the application size increased as most of the business logic moved to frontend. To overcome this, people started using build tools like Webpack, Vite, etc to build chunks of the application and load them when needed (importing components dynamically). Though this solved some of the performance issues and improved initial loading time, the application is now more dependent on JavaScript. What if you disable JavaScript in your browser? By the way, no one does this in reality.

![](/images/6_1.png){m-auto}

In the above image, to change a portion of the page, you send an HTTP (REST or GraphQL) request and manage the JSON reponse on the frontend. It might be possible that you store that response in local storage or use some store management solution (Redux, Pinia, etc). For better user experience, you update that local object and send the changes (after few seconds) to server to make the changes in the database. This is how you sync the state between frontend and backend. Imagine backend could not perform the database operation and you showed some optimistic message to the user assuming backend will not fail. Once the user refreshes the page, he is shown old state stored in database. This is one of the **real** problems.

Now, this is not just limited to technology (or framework), but also developer experience. In a mid-size project, you often have different frontend and backend technologies. Thus you have different teams with different skill sets. Backend developer just focuses on implementing business use cases and cares only about JSON request and response. Frontend developer plays with styling, component libraries, state management, HTTP/GraphQL, cookies, security, etc. There are times where you even need to include multiple frameworks in the frontend to serve some speicific needs (Astro - Island Architecture :smiley:).

Even to design a small component, frontend and backend developers need to sit and discuss the API parameters before writing the code. The classes (Object Oriented) in the backend and frotend start looking similar. More duplicacy. Even when one property in a backend class changes, related changes need to be made in frontend as well. Technically they are separate, but they are tightly coupled. Ultimately, different worlds with different technologies, taking the project cost up and chances of technical debt high. Trust me, managing multi-language system is challenging.

## The Solution

Elixir with Phoenix LiveView can streamline your team, can help you reduce your cost and improve the UX, development and application performace. To just realize this one line, you need to know Elixir and LiveView both very well. In this article we will see how server communicates with browser client.

![](/images/6_2.png){m-auto}

When the very first request is sent to the server, the server sends the whole HTML page with whatever data it has at the moment. There is nothing new here, it is same HTTP request and HTML response seen in other SSR frameworks.

![](/images/6_3.png){m-auto}

But as soon as the page is rendered in the frontend, a persistent websocket connection is established between client and LiveView process (server) which is used for all future communication. This LiveView process will serve only this client. If there is any other user accessing the same page, there will be a different LiveView process for it. So, let's say user clicks some button and expects a _Hellow World!_ text from the server. Here the client will send an event over websocket and that event will be captured by `handle_event` RPC (Remote Procedural Call). Then the `handle_event` updates the internal state, and whenever the state changes, `render` method gets called. Now render method will use the data stored in the state and send only the delta (not the whole page) unlike traditional SSR frameworks. If you have used React/Vue, you might know change in state variable (useState / ref) triggers the merging of Virtual DOM with real DOM. It's same concept, but mostly managed at the backend.

But wait, hasn't any other framework tried websocket method before? Yes, by MeteorJS (a full-stack Javascript framework), but it leans more towards SPA frameworks. I suggest you to check this framework once for your knowledge. While both Phoenix LiveView and MeteorJS use websockets to facilitate real-time communication between the server and the client, they have different approaches to handling updates. Phoenix LiveView uses a server-centric approach, where the server takes more control over the application's state and logic. The client sends events to the server, and the server responds with updated HTML, which is then rendered on the client side. This means that most of the application logic resides on the server.

Now, it's not just LiveView why any developer will go and learn Elixir and then Phoenix. It is the whole platform. In the below diagram you can see that your application is made up of different parts.

![](/images/6_4.png){m-auto}

- **LiveView:** We will talk more on this.
- **Phoenix:** A popular web framework for building scalable and fault-tolerant web applications using Elixir. It provides a robust set of tools and conventions for building modern, real-time applications.
- **Presence:** A feature in the Phoenix framework that allows developers to track and manage real-time presence, such as user presence in a chat room or online status. It provides easy-to-use functionality for handling presence-related tasks in distributed systems.
- **PubSub:** Short for "Publish-Subscribe," is a pattern used in Elixir and Phoenix for broadcasting messages between different parts of an application. It allows for decoupled communication, where one part of the system can publish messages, and other parts can subscribe to receive those messages, facilitating communication between different processes or nodes in a distributed system.
- **OTP:** Stands for "Open Telecom Platform" and is a set of libraries, conventions, and tools that come with Elixir and Erlang for building highly scalable and fault-tolerant applications. OTP provides a framework for building distributed systems, managing processes, and handling failures, making it a key part of building reliable Elixir applications.
- **ErlangVM:** Short for "Erlang Virtual Machine," is the runtime environment that executes Elixir and Erlang code. It is known for its concurrency model, fault-tolerance, and scalability, making it ideal for building distributed systems and highly available applications. Elixir code runs on the ErlangVM, leveraging its capabilities for building robust and reliable applications.

## Setup

Let's start by looking at simple counter example. I am creating the app with 'basics_with_amit' name because I will host many examples in the same app.

### Create App

```elixir
mix phx.new basics_with_amit
```

Install the dependencies, compile it and change into the directory.

```elixir
cd basics_with_amit

mix setup
```

You can install Postgres if you don't have it and ensure the credentials you setup for database are same in your `dev.exs` file.

Start the server. Your application would be running on `http://localhost:4000`.

```elixir
mix phx.server
```

If your application doesn't start, check your port `4000` is not occupied by any other app. We will be using TailwindCSS for all of our current and future LiveView examples. If you have Phoenix 1.6, then you need to add it manually. You can refer official [guide](https://tailwindcss.com/docs/guides/phoenix). But if you have Phoenix 1.7, then it comes by default.

### Add a Live Route

Open your `router.ex` file and update it as below.

```elixir
  scope "/", BasicsWithAmitWeb.Live do
    pipe_through :browser

    live "/counter", CounterLive
  end
```

All live routes are defined using `live` macro. It takes a path ('/counter') and LiveView module (CounterLive) to use. Our request `/counter` will be routed to CounterLive module. But we need to create that module first.

### Create a LiveView Module

It is a good practice to keep your LiveView modules in **live** directory because it's possible there are non-LiveView modules as well in your application. Create **live** directory under **basics_with_amit_web** directory. In earlier versions, this used to get created when you create a new project. You can use other name for the directory but need to update the pattern in the dev config. E.g `live_reload: [ patterns: [...] ]`.

Create a `counter_live.ex` file.

```elixir
defmodule BasicsWithAmitWeb.Live.CounterLive do
  use BasicsWithAmitWeb, :live_view
end
```

All the functionality of LiveView will be added by `use BasicsWithAmitWeb, :live_view`.

### Define Callback Functions

To create a LiveView module, we must include three callback functions:

- **mount:** It will be called after the LiveView process is created. It's is similar to ngOnInt in Angular and onMounted in VueJS. It is used to set the initial state of the LiveView process.

- **handle_event:** As the name suggests, it will handle user events. It is used to update the state of the process.

- **render:** It returns the HTML content to the browser with the update state of the process.

We will first see how `mount` function looks.

```elixir
defmodule BasicsWithAmitWeb.Live.CounterLive do
  use BasicsWithAmitWeb, :live_view

  def mount(_params, _session, socket) do
  end
end
```

It takes three arguments:

- **params:** A map holding query and route params

- **session:** A map holding private session data

- **socket:** A struct representing the websocket connection

In this article, we will focus just on `socket` and that's why we have preceded other two params with hyphen. Whatever data user sees on the frotnend would be from `socket` struct. It represents the state of the process.

Because we want the counter to start from `0`, we will set its initial state in `mount` function.

```elixir
def mount(_params, _session, socket) do
    socket = assign(socket, :counter, 0)
    {:ok, socket}
end
```

Inside the socket struct, there is `assigns` map. It holds all the properties. To add or update those properties, you can use `assign` function. `mount` must return an `:ok` tuple with new socket. You can also inline it as shown below without using temporary variable.

```elixir
def mount(_params, _session, socket) do
    {:ok, assign(socket, :counter, 0)}
end
```

Here we have just one key (counter) to add, but if you want to add/update multiple keys, you can use keyword list also.

Because LiveView knows that the `socket` has been updated, it will call `render` function automatically. Let's define `render` function.

```elixir
def render(assigns) do
    ~H"""
    <div class="flex items-center justify-center h-screen w-screen">
        <span class="font-bold px-4 text-xl"}>
        <%= @counter %>
        </span>
    </div>
    """
end
```

The `render` function accepts `assigns` map where all key/value pairs are stored. We can access the keys directly in the template using `@`. This is handy if you are using many keys. Though you can access it using `assigns.counter` if you like. We are using `~H` sigil for writing HTML code. It creates inline HEEx (HTML + Embeded Elixir) template. You can also create separate file for HTML code and reference it here.

::bonus{noOfStars = 4}
If you are curious what the `socket` struct looks like, then you can inspect it in `mount`.

```elixir
  def mount(_params, _session, socket) do
    socket = assign(socket, :counter, 0)
    IO.inspect(socket)
    {:ok, socket}
  end
```

Output:

```elixir
#Phoenix.LiveView.Socket<
  id: "phx-F1dT75mJ2B_pYgNB",
  endpoint: BasicsWithAmitWeb.Endpoint,
  view: BasicsWithAmitWeb.Live.CounterLive,
  parent_pid: nil,
  root_pid: #PID<0.843.0>,
  router: BasicsWithAmitWeb.Router,
  assigns: %{
    __changed__: %{counter: true},
    counter: 0,
    flash: %{},
    live_action: nil
  },
  transport_pid: #PID<0.838.0>,
  ...
>
```

Check the `assigns` map. We will discuss about other fields later.
::

Let's make our code little interactive by adding increase/decrease buttons.

```elixir
  def render(assigns) do
    ~H"""
    <div class="flex items-center justify-center h-screen w-screen">
      <div>
        <button class="bg-gray-300 py-2 px-4" phx-click="decrease">-</button>
        <span>
        <%= assigns.counter %>
        </span>
        <button class="bg-gray-300 py-2 px-4" phx-click="increase">+</button>
      </div>
    </div>
    """
  end
```

![](/images/6_5.jpeg){mx-auto w-full}

Whenever a button is clicked we need to inform our **CounterLive** process to update the counter. To do that we will use `phx-click` attribute. It's like an Angular or VueJS directive which listens to native click event and sends the value (event name) through the websocket. We have defined two events: `increase` and `decrease`.

```elixir
def handle_event("increase", _, socket) do
    counter = socket.assigns.counter + 1
    socket = assign(socket, :counter, counter)
    {:noreply, socket}
end

def handle_event("decrease", _, socket) do
    counter = socket.assigns.counter - 1
    socket = assign(socket, :counter, counter)
    {:noreply, socket}
end
```

Because we want to increase/decrease on top of the existing counter value, we can access the current value using `socket.assigns.counter`. But introducing temporary variable is not a good idea. We can improve above code using `update` function.

```elixir
def handle_event("increase", _, socket) do
    socket = update(socket, :counter, fn c -> c + 1 end)
    {:noreply, socket}
end

def handle_event("decrease", _, socket) do
    socket = update(socket, :counter, fn c -> c - 1 end)
    {:noreply, socket}
end
```

The third parameter in `update` function is a function. It receives current value and returns the updated value. Now that we know it uses function, we can further make it more consise using **capture** operator.

```elixir
def handle_event("increase", _, socket) do
    socket = update(socket, :counter, &(&1 + 1))
    {:noreply, socket}
end

def handle_event("decrease", _, socket) do
    socket = update(socket, :counter,  &(&1 - 1))
    {:noreply, socket}
end
```

If you are new to the **capture** operator, you can refer below article.

::related-posts
[- Functions](functions)
::

What if I want to change the color of the counter value when it's positive and negative? We can use conditional/dynamic classes.

```elixir
def render(assigns) do
    ~H"""
    <div class="flex items-center justify-center h-screen w-screen">
      <div>
        <button class="bg-gray-300 py-2 px-4" phx-click="decrease">-</button>
        <span  class={"#{ if @counter < 0, do: "text-red-600", else: if @counter > 0, do: "text-green-600", else: "text-black"} font-bold px-4 text-xl"}>
        <%= assigns.counter %>
        </span>
        <button class="bg-gray-300 py-2 px-4" phx-click="increase">+</button>
      </div>
    </div>
    """
end
```

![](/images/6_6.jpeg){mx-auto w-full}
![](/images/6_7.jpeg){mx-auto w-full}

Although the code is quite simple, you can pay attention to dynamic classes in class attribute. See how we can use `#{...}` to add dynamic code. You might wonder why we are not using `<%= .... %>` inside the tag. Well the `<%= .... %>` pattern can only be used inside the **body** of the tag.

Right now, the value by which it will increase/decrease is 1. If we want to pas the custom value, we can use `phx-value-number` binding. Consider the last word `number` as a variable which you will receive in `handle_event`.

```html
<button class="bg-gray-300 py-2 px-4" phx-click="increase" phx-value-number="2">
  +
</button>
```

The data that you will receive will be in below format. `value` is empty because we have not set any **value** attribute on the button.

```elixir
%{"number" => "2", "value" => ""}
```

Now, you can use the pattern matching and just fetch the `number` from the map.

```elixir
def handle_event("increase", %{"number" => number}, socket) do
    socket = update(socket, :counter, &(&1 + String.to_integer(number)))
    {:noreply, socket}
end
```

If you don't want to use pattern matching, you can also access the whole map.

```elixir
def handle_event("increase", data, socket) do
    socket = update(socket, :counter, &(&1 + String.to_integer(data["number"])))
    {:noreply, socket}
end
```

::bonus{noOfStars = 2}
To access the string key in the map, we need to use `map["string_key"]`. If it were atom (`%{number: "2", value: ""}`), we could use `map.key` (dot notation).
::
