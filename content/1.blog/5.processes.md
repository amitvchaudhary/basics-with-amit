---
title: Processes
description: Let the process crash
createdAt: 2023-03-08
head.title: Processes
head.description: Let the process crash
---

::post-image{imageSrc="header_5.jpg"}
Processes
::

If you have just started learning Elixir, then you must have read about LiveView components. They are super powerful and I believe they will replace React/Angular/VueJS one day. I claim this because I have used all aforementioned frameworks for quite a long time and I strongly feel, Elixir LiveView will be the future for frontend development. But before you accept what I just said and start creating new project, I suggest you to understand this post thoroughly. This doesn't mean you can't start with LiveView without reading this post, but if you know what goes under the hood, you will appreciate its architecture and design decisions. In this post we are NOT going to talk about LiveView, but what powers it - **Process**.

**Tip:** :moneybag: If you want to convince your developer or manager to start using Elixir in projects, you won't succeed if you can't explain why. This post will help you in answering 'why'. :sunflower:

Every business person wants his product (system) to run for 24x7 and make his customers happy. But this wish can only be fulfilled if the system fulfills below parameters:

- _Fault-tolerance_: Recover from the effects of runtime errors.
- _Scalability_: Handle increase in requests by adding more hardware resources, but not redeploying the code.
- _Distribution_: If one server fails, another takes over the work

You might have read above terms with respect to **Cloud Computing**. It's because in cloud, the cloud provider takes care of them. But it doesn't come for free. You need to pay. Sometimes, even after spending good amount of money, business owners or backend developers can't do much due to poor choice of backend language. But what if I tell you, from my own experience, that you can reduce your billing if you use Elixir? It sounds lucrative and it is. The reason for that is again a **Process**.

In this post, when I say _Process_, I mean BEAM Process and NOT an OS process. BEAM is a Virtual Machine that runs the processes. The BEAM process is way lighter than OS process. In fact whole BEAM runs on a single OS process. You must be knowing that OS process can spawn multiple **threads** to achieve concurrency. So, it means a thread is lighter than an OS process. But BEAM process is so light that it takes couple of microseconds to create and just few KBs as compared to OS thread which takes couple of megabytes even just for the stack. It is said that BEAM VM can spawn roughly 134 million processes :open_mouth: FYI, ther is no concept of **threads** in Elixir.

![](/images/5_1.png){m-auto}

You can see in the above diagram that how one OS process has four OS threads running BEAM schedulers. The no. of schedulers depend on the no. of OS threads. If you have quad-core machine, then you can have four OS threads which can handle four BEAM schedulers. A scheduler is in charge of the interchangeable execution of processes. Each process gets some time; after the time is up, the running process is preempted, and the next one takes over.

## Anatomy

Process is an isolated entity where code execution happens. It's just a block of memory where you are going to store data and manipulate it. The best part of process is that it doesn't share its state with another process, unlike threads (Java, etc). Because of this, you can run tasks simultaneously without worring about dependency. If one process crashes, it won't affect the other ones. But, if you want that behavior, you can. We will see that little later. But when we have multiple processes running parallelly, we can achieve _scalability_ to address a load increase by adding more hardware power. BEAM scheduler will ensure there is proper utilization of CPU resources. Because process runs in isolation, it also guarantees _fault tolerance_ as it localizes the impact of runtime errors.

![](/images/5_2.png){m-auto}

You can see in the above diagram that process is just a block of memory with following parts:

- **Stack** - To keep local variables
- **Heap** - To keep larger structures
- **Mailbox** - To store messages sent from other processes
- **PCB** - A process control block to keep track of the current state
- **PID** - A process identifier to uniquely identify the process

We will focus more on **mailbox** and **pid** as rest are self-explanatory to any developer.

### One Process

Before you learn to create a process, you might not know that till now, if you are using `iex` terminal to practice Elixir, you have been using process. Yes, the shell is a process. The first thing to know about any process is its identifier, _pid_. To get the _pid_ of your shell, just run `self()` function.

```elixir
iex> self()
#PID<0.107.0>
```

`#PID<0.107.0>` is the pointer to a process. It's its identity. You can also give a name to it, but we will see that later. The three integers `0.107.0` are unique in the current run of Elixir. If you close the terminal and open again and print the pid again, you might get a different pid this time. Can you assign pid manually to any process? No. It's read-only.

```elixir
iex> #PID<0.107.0>
nil
```

You can know pid of any process as long as you can reach there. If you have process running on another computer and if you are in same cluster, you can reach that process and thus get its pid.

Without knowing pids, you can't communicate with other processes. Pids act like addresses for mailboxes, where messages are dropped from other processes. But yes, a process can also drop message to itself. To send a message, to self or any other process, you need to use `send/2` function. The first argument is the pid and second one is the message. The message can be of any type - atom, map, list, etc.

```elixir
iex> send(self(), :hello)
:hello
iex> pid = self()
#PID<0.107.0>
iex> send(pid, :amit)
:amit
iex> send(pid, :amit)
:amit
```

![](/images/5_3.png){m-auto}

Here, the process is sending the messages to itself. Interesting thing to note here is that the output `:hello` and `:amit` is from the function `send/2` and not from the its mailbox. The messages are still lying in the mailbox. If you want to see the messages in the mailbox, use `flush()` function. But one thing to be aware is that it will remove those messages as well.

```elixir
iex> flush()
:hello
:amit
:amit
:ok
iex> flush()
:ok
```

You must observe one more thing in above output. Though we had sent same message `:amit` twice, it created another message and didn't replace the previous one. Each message is isolated. Also `:ok` is the result of `flush()` function notifying that it was successful in fetching the messages from the mailbox.

`flush()` can be useful in many scenarios. It empties the mailbox everytime you use it. But it would be good if we can process individual message and act accordingly. For that we can use `receive...end` construct.

```elixir
iex> send(self(), :amit)
:amit
iex> receive do
...>   x -> x
...> end
:amit
iex> send(self(), 20)
20
iex> receive do
...>   x -> x * 2
...> end
40
```

`receive...end` construct waits for a message and exits after fetching one. So, if there is no message in the mailbox or you have some other pattern in the construct which doesn't meet the message format, the process will hang there. Try below:

- **Case 1:** no messages

```elixir
iex> send(self(), :amit)
:amit # printed by send() function
iex> receive do
...>   x -> x
...> end
:amit # received from mailbox, so no more messages now
iex> receive do
...>   x -> x
...> end
# in hang state. Press Ctrl + C to exit and restart iex
```

- **Case 2:** unexpected pattern

```elixir
iex> send(self(), :amit)
:amit # printed by send() function
iex> receive do
...>   :hello -> :hello # expecting :hello but received :amit
...> end
# in hang state. Press Ctrl + C to exit and restart iex
```

**Case 1** is self-explanatory but why did it stuck in **Case 2**? Because it thinks that some process will send some message with `:hello` format. If it does, then it will print it and exit.

### Two Processes

Till now we played with the process that was already there, shell process. Now, it's time to send message from shell process to another. But for that we need to create the process first. For that you can use `spawn/1` function.
