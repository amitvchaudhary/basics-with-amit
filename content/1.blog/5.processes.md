---
title: Processes
description: Let the process crash
createdAt: 2023-03-08
head.title: Processes
head.description: Let the process crash
---

::post-image{imageSrc="header_5.jpg"}
Processes
::

If you have just started learning Elixir, then you must have read about LiveView components. They are super powerful and I believe they will replace React/Angular/VueJS one day. I claim this because I have used all aforementioned frameworks for quite a long time and I strongly feel, Elixir LiveView will be the future for frontend development. But before you accept what I just said and start creating new project, I suggest you to understand this post thoroughly. This doesn't mean you can't start with LiveView without reading this post, but if you know what goes under the hood, you will appreciate its architecture and design decisions. In this post we are NOT going to talk about LiveView, but what powers it - **Process**.

**Tip:** :moneybag: If you want to convince your developer or manager to start using Elixir in projects, you won't succeed if you can't explain why. This post will help you in answering 'why'. :sunflower:

Every business person wants his product (system) to run for 24x7 and make his customers happy. But this wish can only be fulfilled if the system fulfills below parameters:

- _Fault-tolerance_: Recover from the effects of runtime errors.
- _Scalability_: Handle increase in requests by adding more hardware resources, but not redeploying the code.
- _Distribution_: If one server fails, another takes over the work

You might have read above terms with respect to **Cloud Computing**. It's because in cloud, the cloud provider takes care of them. But it doesn't come for free. You need to pay. Sometimes, even after spending good amount of money, business owners or backend developers can't do much due to poor choice of backend language. But what if I tell you, from my own experience, that you can reduce your billing if you use Elixir? It sounds lucrative and it is. The reason for that is again a **Process**.

In this post, when I say _Process_, I mean BEAM Process and NOT an OS process. BEAM is a Virtual Machine that runs the processes. The BEAM process is way lighter than OS process. In fact whole BEAM runs on a single OS process. You must be knowing that OS process can spawn multiple **threads** to achieve concurrency. So, it means a thread is lighter than an OS process. But BEAM process is so light that it takes couple of microseconds to create and just few KBs as compared to OS thread which takes couple of megabytes even just for the stack. It is said that BEAM VM can spawn roughly 134 million processes :open_mouth: FYI, ther is no concept of **threads** in Elixir.

![](/images/5_1.png){m-auto}

You can see in the above diagram that how one OS process has four OS threads running BEAM schedulers. The no. of schedulers depend on the no. of OS threads. If you have quad-core machine, then you can have four OS threads which can handle four BEAM schedulers. A scheduler is in charge of the interchangeable execution of processes. Each process gets some time; after the time is up, the running process is preempted, and the next one takes over.

## Anatomy

Process is an isolated entity where code execution happens. It's just a block of memory where you are going to store data and manipulate it. The best part of process is that it doesn't share its state with another process, unlike threads (Java, etc). Because of this, you can run tasks simultaneously without worring about dependency. If one process crashes, it won't affect the other ones. But, if you want that behavior, you can. We will see that little later. But when we have multiple processes running parallelly, we can achieve _scalability_ to address a load increase by adding more hardware power. BEAM scheduler will ensure there is proper utilization of CPU resources. Because process runs in isolation, it also guarantees _fault tolerance_ as it localizes the impact of runtime errors.

![](/images/5_2.png){m-auto}

You can see in the above diagram that process is just a block of memory with following parts:

- **Stack** - To keep local variables
- **Heap** - To keep larger structures
- **Mailbox** - To store messages sent from other processes
- **PCB** - A process control block to keep track of the current state
- **PID** - A process identifier to uniquely identify the process

We will focus more on **mailbox** and **pid** as rest are self-explanatory to any developer.

### Create
