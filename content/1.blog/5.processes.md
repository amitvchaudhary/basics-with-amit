---
title: Processes
description: Let the process crash
createdAt: 2023-03-08
head.title: Processes
head.description: Let the process crash
---

::post-image{imageSrc="header_5.jpg"}
Processes
::

If you have just started learning Elixir, then you must have read about LiveView components. They are super powerful and I believe they will replace React/Angular/VueJS one day. I claim this because I have used all aforementioned frameworks for quite a long time and I strongly feel, Elixir LiveView will be the future for frontend development. But before you accept what I just said and start creating new project, I suggest you to understand this post thoroughly. This doesn't mean you can't start with LiveView without reading this post, but if you know what goes under the hood, you will appreciate its architecture and design decisions. In this post we are NOT going to talk about LiveView, but what powers it - **Process**.

**Tip:** :moneybag: If you want to convince your developer or manager to start using Elixir in projects, you won't succeed if you can't explain why. This post will help you in answering 'why'. :sunflower:

Every business person wants his product (system) to run for 24x7 and make his customers happy. But this wish can only be fulfilled if the system fulfills below parameters:

- _Fault-tolerance_: Recover from the effects of runtime errors.
- _Scalability_: Handle increase in requests by adding more hardware resources, but not redeploying the code.
- _Distribution_: If one server fails, another takes over the work

You might have read above terms with respect to **Cloud Computing**. It's because in cloud, the cloud provider takes care of them. But it doesn't come for free. You need to pay. Sometimes, even after spending good amount of money, business owners or backend developers can't do much due to poor choice of backend language. But what if I tell you, from my own experience, that you can reduce your billing if you use Elixir? It sounds lucrative and it is. The reason for that is again a **Process**.

In this post, when I say _Process_, I mean BEAM Process and NOT an OS process. BEAM is a Virtual Machine that runs the processes. The BEAM process is way lighter than OS process. In fact whole BEAM runs on a single OS process. You must be knowing that OS process can spawn multiple **threads** to achieve concurrency. So, it means a thread is lighter than an OS process. But BEAM process is so light that it takes couple of microseconds to create and just few KBs as compared to OS thread which takes couple of megabytes even just for the stack. It is said that BEAM VM can spawn roughly 134 million processes :open_mouth: FYI, ther is no concept of **threads** in Elixir.

![](/images/5_1.png){m-auto}

You can see in the above diagram that how one OS process has four OS threads running BEAM schedulers. The no. of schedulers depend on the no. of OS threads. If you have quad-core machine, then you can have four OS threads which can handle four BEAM schedulers. A scheduler is in charge of the interchangeable execution of processes. Each process gets some time; after the time is up, the running process is preempted, and the next one takes over.

## Anatomy

Process is an isolated entity where code execution happens. It's just a block of memory where you are going to store data and manipulate it. The best part of process is that it doesn't share its state with another process, unlike threads (Java, etc). Because of this, you can run tasks simultaneously without worring about dependency. If one process crashes, it won't affect the other ones. But, if you want that behavior, you can. We will see that little later. But when we have multiple processes running parallelly, we can achieve _scalability_ to address a load increase by adding more hardware power. BEAM scheduler will ensure there is proper utilization of CPU resources. Because process runs in isolation, it also guarantees _fault tolerance_ as it localizes the impact of runtime errors.

![](/images/5_2.png){m-auto}

You can see in the above diagram that process is just a block of memory with following parts:

- **Stack** - To keep local variables
- **Heap** - To keep larger structures
- **Mailbox** - To store messages sent from other processes
- **PCB** - A process control block to keep track of the current state
- **PID** - A process identifier to uniquely identify the process

We will focus more on **mailbox** and **pid** as rest are self-explanatory to any developer.

### One Process

Before you learn to create a process, you might not know that till now, if you are using `iex` terminal to practice Elixir, you have been using process. Yes, the shell is a process. The first thing to know about any process is its identifier, _pid_. To get the _pid_ of your shell, just run `self()` function.

```elixir
iex> self()
#PID<0.107.0>
```

`#PID<0.107.0>` is the pointer to a process. It's its identity. You can also give a name to it, but we will see that later. The three integers `0.107.0` are unique in the current run of Elixir. If you close the terminal and open again and print the pid again, you might get a different pid this time. Can you assign pid manually to any process? No. It's read-only.

```elixir
iex> #PID<0.107.0>
nil
```

You can know pid of any process as long as you can reach there. If you have process running on another computer and if you are in same cluster, you can reach that process and thus get its pid.

Without knowing pids, you can't communicate with other processes. Pids act like addresses for mailboxes, where messages are dropped from other processes. But yes, a process can also drop message to itself. To send a message, to self or any other process, you need to use `send/2` function. The first argument is the pid and second one is the message. The message can be of any type - atom, map, list, etc.

```elixir
iex> send(self(), :hello)
:hello
iex> pid = self()
#PID<0.107.0>
iex> send(pid, :amit)
:amit
iex> send(pid, :amit)
:amit
```

![](/images/5_3.png){m-auto}

Here, the process is sending the messages to itself. Interesting thing to note here is that the output `:hello` and `:amit` is from the function `send/2` and not from the its mailbox. The messages are still lying in the mailbox. If you want to see the messages in the mailbox, use `flush()` function. But one thing to be aware is that it will remove those messages as well.

```elixir
iex> flush()
:hello
:amit
:amit
:ok
iex> flush()
:ok
```

You must observe one more thing in above output. Though we had sent same message `:amit` twice, it created another message and didn't replace the previous one. Each message is isolated. Also `:ok` is the result of `flush()` function notifying that it was successful in fetching the messages from the mailbox.

`flush()` can be useful in many scenarios. It empties the mailbox everytime you use it. But it would be good if we can process individual message and act accordingly. For that we can use `receive...end` construct.

```elixir
iex> send(self(), :amit)
:amit
iex> receive do
...>   x -> x
...> end
:amit
iex> send(self(), 20)
20
iex> receive do
...>   x -> x * 2
...> end
40
```

`receive...end` construct waits for a message and exits after fetching one. So, if there is no message in the mailbox or you have some other pattern in the construct which doesn't meet the message format, the process will hang there. Try below:

- **Case 1:** no messages

```elixir
iex> send(self(), :amit)
:amit # printed by send() function
iex> receive do
...>   x -> x
...> end
:amit # received from mailbox, so no more messages now
iex> receive do
...>   x -> x
...> end
# in hang state. Press Ctrl + C to exit and restart iex
```

- **Case 2:** unexpected pattern

```elixir
iex> send(self(), :amit)
:amit # printed by send() function
iex> receive do
...>   :hello -> :hello # expecting :hello but received :amit
...> end
# in hang state. Press Ctrl + C to exit and restart iex
```

**Case 1** is self-explanatory but why did it stuck in **Case 2**? Because it thinks that some process will send some message with `:hello` format. If it does, then it will print it and exit.

To avoid keeping process in hung state, you can use `after` construct of the `receive ... end` clause.

```elixir
iex> receive do
...>    :hello -> :hello # expecting :hello but received :amit
...> after
...>   30000 -> IO.puts("Stopping, no more messages")
...>  end
Stopping, no more messages
:ok
```

Intersting thing to know is that it didn't raise an error when there was no pattern match unlike explained in below topic.

::related-posts
[- Error Handling](error-handling)
::

Because, the `receive` construct is an exception to this rule. If a message doesn't match any of the provided clauses, it's put back into the mailbox and the next message is processed. This is how the flow looks like:

1. Take the first message from mailbox
2. Match the pattern from top to bottom
3. If there is a match, run the corresponding code
4. If there is no match, put the message back to same position in mailbox and try next message
5. If there is no more message in the mailbox, wait for it and one there is any, start from picking the first message in the mailbox
6. If you have `after` clause mentioned, then it will run if there are no more messages in the mailbox within the specified time

### Two Processes

Till now we played with the process that was already there, shell process. Now, it's time to send message from shell process to another. But for that we need to create another process first. For that you can use `spawn/1` function. This function takes zero-arity lambda that will run in another process and return process indentifier. Once the other process completes its work, it exits. While the other process does its work, the caller process won't be blocked, it can continue its work as both processes are running in parallel.

```elixir
iex> spawn(fn -> IO.puts("I am a new process") end)
I am a new process
#PID<0.109.0>
```

Here, you got a pid `#PID<0.109.0>` of another process and also the output. We gave the process an anonymous function to execute and it printed `I am a new process`. But there is one more thing.

```elixir
iex> spawn(fn -> 1 + 1 end)
#PID<0.111.0>
```

Why didn't you get `2` as an output? Because we didn't tell the process to send the computed result back to us (shell process). We just told to do computation. Then how come the `I am a new process` got printed in previous process? That's because you told to print the result in ANOTHER process. That was it's main job. It didn't send anything back. If you want the result back, then you need to send your (shell process) pid `#PID<0.107.0>` to another process `#PID<0.111.0>` and tell it to send the result back with the help of `send/2` as we had seen earlier.

Now how do you check whether the newly created process is still alive (running or not)?

```elixir
iex> pid = spawn(fn ->
...> Process.sleep(10000)
...> IO.puts('I slept for 10 seconds')
...> end
...> )
#PID<0.120.0>
iex> Process.alive?(pid)
true
I slept for 10 seconds
iex> Process.alive?(pid)
false
```

Because `Process.alive?(pid)` was executed just before 10 seconds completed, it printed `true`. Now try below code.

```elixir
iex> Process.alive?(self())
true
```

I am sure you know why it printed `true`. Let's move ahead.

It's more common to use `spawn/1` and pass zero-arity lambdas for testing purpose. But in real code, you will most like use modules and named functions. Processes at their heart are just functions and by now you know how to define functions in modules. If not, please go through below post first.

::related-posts
[- Functions](functions)
::

Let's define a module called `Robot` and define a named called function `show` whose main responsibility to just display messages.

```elixir
defmodule Robot do
  def show do
    receive do
      msg -> IO.puts("Received #{msg}")
    end
  end
end
```

We are well aware about `receive ... end` construct. It's is quite similar to `case ... end` construct. So, we just put `receive ... end` inside `show/0` function so that we don't need to write `receive ... end` everytime we want to fetch one message and just call `show/0`. This time, to create a process, we will use `spawn/3` function instead.

```elixir
iex> pid = spawn(Robot, :show, [])
#PID<0.138.0>
```

The arguments are the module name, function name (as an atom), and a list of arguments to the function. You must have noticed that though `show/0` function doesn't accept any parameter, it is still necessary to pass an empty list `[]`.

Now, it's time to send our first message.

```elixir
iex> send(pid, "Wow ...")
Received Wow ...
"Wow ..."
```

`Received Wow ... ` is from the spawned process whereas `Wow ...` is from `send/2` function. Now let's send one more message.

```elixir
iex> send(pid, "Second message ...")
"Second message ..."
```

You see that output is from `send/2` function and not the other process. This is because `show` process exited after fetching the first message `Wow ...`. This also means that if you send a message to a stopped process, you won't get an error but you will also not get any notification that the message was received because no process is listening to it.

We need a process which runs for long time (or forever). We can give such process a name, _server process_. Is there a special way to create a server process? Actually no. We use the same `spawn()` function but use recursion technique in the process.

```elixir
defmodule Robot do
  def show do
    receive do
      msg -> IO.puts("Received #{msg}")
      show() # recursion
    end
  end
end
```

We are just telling the process to call `show()` function again after it finishes to process the first message. This will make it wait until the new message arrives and it will go on like that.

```elixir
iex> send(pid, "first")
Received first
"first"
iex> send(pid, "second")
"second"
Received second
iex> send(pid, "third")
Received third
"third"
```

::bonus{noOfStars = 5}
If you notice the second message carefully, the message `Received second` was printed after the message from `send()`. This is due to the fact that processes are asynchronous, so the order may differ every time you send a message.
::

We can improve our process a little bit by introducing accumulator to keep track of no. of messages the process prints.

```elixir
defmodule Robot do
  def show(count) do
    receive do
      msg -> IO.puts("Received #{count}: #{msg}")
      show(count + 1)
    end
  end
end
```

Before you spawn a new process, ensure you pass initial value in the argument list.

```elixir
iex> pid = spawn(Robot, :show, [1])
#PID<0.162.0>
```

Now, let's send the messages again.

```elixir
iex> send(pid, "first")
Received 1: first
"first"
iex> send(pid, "second")
Received 2: second
"second"
iex> send(pid, "third")
Received 3: third
"third"
```

The output looks satisfactory. But won't recursion cause stack overflow? Answer is **No**. But why? Unlike other programming languages, in Elixir, if the last thing that a function does is call another function (or itself), then it is not pushed to stack or allocated memory, but it jumps (similar to go-to statement). This is called tail call optimization. This way, you can have endless loop without being worried about memory leakage.
