---
title: Functions
description: Function clauses, Function Overloading
createdAt: 2022-12-30
head.title: Functions
head.description: Function clauses, Function Overloading
---

::post-image{imageSrc="header_3.jpg"}
Functions
::

::related-posts

[- Patterns, Patterns and Patterns](pattern-matching)
::

Due to Elixir being functional programming language, you will find any Elixir code inundated with lots of small functions. And that's why functions are first-class citizens in Elixir. This means, you can pass around functions like any normal variables. You might be already accustomed to it if you have used JavaScript before. But there are few nuances in Elixir functions which you will appreciate for sure.

## Modules

A module is a bunch of functions, somewhat similar to a **namespace**. They are grouped together because they are somehow related. In objected-oriented languages, **data** and **functions** are encapuslated in objects. But in Elixir they are kept separate because data in Elixir is immutable and it doens't make much sense to keep them together. For example, all string manipulation functions are grouped in `String` module and all functions relating to lists are kept in the `List` module.

You can create a module using `defmodule` construct with the contents of the module enclosed between `do` and `end`.

```elixir
defmodule Animals.Feline.Cat do

end
```

By the way they can also be nested. Both above and below are equivalent.

```elixir
defmodule Animals.Feline do
    defmodule Cat do

    end
end
```

It is important to know that a module must be defined in a single file. You cannot have multiple source code files of a single function. But, you can have multiple modules in a single file, which is obvious. LOL.

::bonus{noOfStars = 5}

Like any programming language, Elixir modules must follow some naming conventions. A module starts with an uppercase letter and is usually written in CamelCase style. It can consist of **alphanumerics**, **underscores**, and the **dot (.)** character.

The **dot (.)** character is for your convenience. When the code is compiled, there is no hierarchy. It is just for you to scope your names.

Below code can be referenced as `Animals.Feline.Cat`. Remember, though the code looks hierarchical to you, it is not when compiled.

```elixir
defmodule Animals.Feline do
    defmodule Cat do

    end
end
```

Another interesting fact is You will be surprised to know that in Elixir, you can refer to other modules even before writing them without any compilation errors.

```elixir
defmodule Animals.Feline do
    defmodule Cat do
        IO.puts(Animals.Canine.Dog);
    end
end
```

Here, though the `Animals.Canine.Dog` is not declared anywhere, you can still use it because module names are converted into atoms internally (in the Erlang VM) and have **Elixir** added to the front. So, the module `Animals.Feline` will convert to `:"Elixir.Animals.Feline"` atom internally and that's why compiler doesn't complain as the atom exists. FYI, atoms need to have quotes around them when they contain a special character like a space or dot.

But if you try to call function before it's declared, you will get below error.

```elixir
iex> IO.puts(Animals.Canine.Dog.bark)
** (UndefinedFunctionError) function Animals.Canine.Dog.bark/0 is undefined (module Animals.Canine.Dog is not available)
    Animals.Canine.Dog.bark()
    iex:4: (file)
```

Erlang module names are also atoms, thus Elixir has adopted same approach. If you monitor the modules in Erlang VM, you will be able to distinguish which modules are from Elixir because of the prefix.

::

## Named Functions

Any function having a name associated to it, is called? You guessed it right. Functions are defined with the `def` keyword followed by a parameter list. Like modules, function body begins with the `do` keyword and ends with the `end` keyword.

```elixir
defmodule OurMathModule do
    def sum(num1, num2) do
        num1 + num2
    end
end
```

It's pretty simple, but one thing to notice is the missing **return** keyword. In Elixir, the value of last statement (or expression) is automatically returned. This is how you write less code. I don't know why other languages haven't adopted this style yet as anyways we can't write anything after **return** keyword.

But is having a name to a function the only reason why it's called **named functions**? Actually, named functions can exist only inside a module. The main reason for this is that you would be able to call named functions from **other** modules, unlike _anonymous functions_.

### Single-line Functions

Sometimes, we don't need functions processing complex logic. In such cases you can opt for concise syntax.

```elixir
def multiply(num1, num2, num3), do: num1 * num2 * num3
```

Once you start coding, I think you will start appreciating above style as your functions would be composed of many small functions. You will experience it.

### Function Names

Now having just a name is not enough. Whenever you read any official docs (or some good code), you will see something like `multiply/3` and not just `multiply`. The `/3` indicates the no. of parameters the function accepts. So the `3` digit in Elixir is called **arity**. Add this to your vocabulary! :closed_book:

It is **arity** which distinguishes one function from another. Yes, because you can have multiple functions with same name. You might be thinking the right word, yes it is **function overloading**. But ideally, they are completely different functions for Elixir due to _arity_.

```elixir
# multiply/3
def multiply(num1, num2, num3), do: num1 * num2 * num3

# multiply/2
def multiply(num1, num2), do: num1 * num2
```

But what if you have same name with same arity?

```elixir
defmodule OurMathModule do
    def multiply(num1, num2, num3) do
        num1 * num2 * num3
    end

    def multiply(num1, num2, num3) do
        num1 * num2 * num3
    end
end
```

I am sure you must be expecting an exception, but Elixir will load it with a warning indicating that the second function will never be called as only the first instance will be defined. :imp:

## Anonymous Functions

Though I don't need to define what this means because this is everywhere nowadays. It is commonly referred as **lambdas**. You just define a function and assign it to a variable and then play :soccer: around with it. Here, anonymous functions start with `fn` keyword and end with `end`. The body and parameters are separated with `->`. It takes some practice avoiding `=>` which you are so used to. :smiley:

```elixir
iex> multiply = fn (num1, num2) -> num1 * num2 end
#Function<41.3316493/2 in :erl_eval.expr/6>
```

By the way you can skip paranthesis if you want.

```elixir
iex> multiply = fn num1, num2 -> num1 * num2 end
#Function<41.3316493/2 in :erl_eval.expr/6>
```

Personally, I encourage you to use paranthesis to improve readability. If we have named functions, then why do we even need such anonymous functions? If you just want to use it and throw away, like paper dish, go with anonymous functions. But if you find yourself writing same lambda again and again, it's time to convert it to a named function.

### Shortcuts

### Referring to a Named Function

## Calling Functions

## Loading a Module into IEx

## Default Parameter Values

## Private Functions

## Function and Module Naming Conventions

## Using Functions from Another Module

## Importing Entire Modules

### Importing Specific Functions from a Module

### Other Ways of Importing

## Module Attributes

---

## Pattern Matching

### Multiclause Functions

### Guards

### Multiclause Lambdas

## Conditionals

### Branching with Multiclause Functions

### Classical

### Branching Constants

### With
