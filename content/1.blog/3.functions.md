---
title: Functions
description: Function clauses, Function Overloading
createdAt: 2022-12-30
head.title: Functions
head.description: Function clauses, Function Overloading
---

::post-image{imageSrc="header_3.jpg"}
Functions
::

::related-posts

[- Patterns, Patterns and Patterns](pattern-matching)
::

Due to Elixir being functional programming language, you will find any Elixir code inundated with lots of small functions. And that's why functions are first-class citizens in Elixir. This means, you can pass around functions like any normal variables. You might be already accustomed to it if you have used JavaScript before. But there are few nuances in Elixir functions which you will appreciate for sure.

## Modules

A module is a bunch of functions, somewhat similar to a **namespace**. They are grouped together because they are somehow related. In objected-oriented languages, **data** and **functions** are encapuslated in objects. But in Elixir they are kept separate because data in Elixir is immutable and it doens't make much sense to keep them together. For example, all string manipulation functions are grouped in `String` module and all functions relating to lists are kept in the `List` module.

You can create a module using `defmodule` construct with the contents of the module enclosed between `do` and `end`.

```elixir
defmodule Animals.Feline.Cat do

end
```

By the way they can also be nested. Both above and below are equivalent.

```elixir
defmodule Animals.Feline do
    defmodule Cat do

    end
end
```

It is important to know that a module must be defined in a single file. You cannot have multiple source code files of a single function. But, you can have multiple modules in a single file, which is obvious. LOL.

::bonus{noOfStars = 5}

Like any programming language, Elixir modules must follow some naming conventions. A module starts with an uppercase letter and is usually written in CamelCase style. It can consist of **alphanumerics**, **underscores**, and the **dot (.)** character.

The **dot (.)** character is for your convenience. When the code is compiled, there is no hierarchy. It is just for you to scope your names.

Below code can be referenced as `Animals.Feline.Cat`. Remember, though the code looks hierarchical to you, it is not when compiled.

```elixir
defmodule Animals.Feline do
    defmodule Cat do

    end
end
```

Another interesting fact is You will be surprised to know that in Elixir, you can refer to other modules even before writing them without any compilation errors.

```elixir
defmodule Animals.Feline do
    defmodule Cat do
        IO.puts(Animals.Canine.Dog);
    end
end
```

Here, though the `Animals.Canine.Dog` is not declared anywhere, you can still use it because module names are converted into atoms internally (in the Erlang VM) and have **Elixir** added to the front. So, the module `Animals.Feline` will convert to `:"Elixir.Animals.Feline"` atom internally and that's why compiler doesn't complain as the atom exists. FYI, atoms need to have quotes around them when they contain a special character like a space or dot.

But if you try to call function before it's declared, you will get below error.

```elixir
iex> IO.puts(Animals.Canine.Dog.bark)
** (UndefinedFunctionError) function Animals.Canine.Dog.bark/0 is undefined (module Animals.Canine.Dog is not available)
    Animals.Canine.Dog.bark()
    iex:4: (file)
```

Erlang module names are also atoms, thus Elixir has adopted same approach. If you monitor the modules in Erlang VM, you will be able to distinguish which modules are from Elixir because of the prefix.

::

## Named Functions

Any function having a name associated to it, is called? You guessed it right. Functions are defined with the `def` keyword followed by a parameter list. Like modules, function body begins with the `do` keyword and ends with the `end` keyword.

```elixir
defmodule OurMathModule do
    def sum(num1, num2) do
        num1 + num2
    end
end
```

It's pretty simple, but one thing to notice is the missing **return** keyword. In Elixir, the value of last statement (or expression) is automatically returned. This is how you write less code. I don't know why other languages haven't adopted this style yet as anyways we can't write anything after **return** keyword.

But is having a name to a function the only reason why it's called **named functions**? Actually, named functions can exist only inside a module. The main reason for this is that you would be able to call named functions from **other** modules, unlike _anonymous functions_.

### Single-line Functions

Sometimes, we don't need functions processing complex logic. In such cases you can opt for concise syntax.

```elixir
def multiply(num1, num2, num3), do: num1 * num2 * num3
```

Once you start coding, I think you will start appreciating above style as your functions would be composed of many small functions. You will experience it.

### Function Names

Now having just a name is not enough. Whenever you read any official docs (or some good code), you will see something like `multiply/3` and not just `multiply`. The `/3` indicates the no. of parameters the function accepts. So the `3` digit in Elixir is called **arity**. Add this to your vocabulary! :closed_book:

It is **arity** which distinguishes one function from another. Yes, because you can have multiple functions with same name. You might be thinking the right word, yes it is **function overloading**. But ideally, they are completely different functions for Elixir due to _arity_.

```elixir
# multiply/3
def multiply(num1, num2, num3), do: num1 * num2 * num3

# multiply/2
def multiply(num1, num2), do: num1 * num2
```

But what if you have same name with same arity?

```elixir
defmodule OurMathModule do
    def multiply(num1, num2, num3) do
        num1 * num2 * num3
    end

    def multiply(num1, num2, num3) do
        num1 * num2 * num3
    end
end
```

I am sure you must be expecting an exception, but Elixir will load it with a warning indicating that the second function will never be called as only the first instance will be defined. :imp:

## Anonymous Functions

Though I don't need to define what this means because this is everywhere nowadays. It is commonly referred as **lambdas**. You just define a function and assign it to a variable and then play :soccer: around with it. Here, anonymous functions start with `fn` keyword and end with `end`. The body and parameters are separated with `->`. It takes some practice avoiding `=>` which you are so used to. :smiley:

```elixir
iex> multiply = fn (num1, num2) -> num1 * num2 end
#Function<41.3316493/2 in :erl_eval.expr/6>
```

To call the above function, use `.` (dot) operator.

```elixir
iex> multiply.(1,2)
2
```

By the way you can skip paranthesis if you want.

```elixir
iex> multiply = fn num1, num2 -> num1 * num2 end
#Function<41.3316493/2 in :erl_eval.expr/6>
```

Personally, I encourage you to use paranthesis to improve readability. If we have named functions, then why do we even need such anonymous functions? If you just want to use it and throw away, like paper dish, go with anonymous functions. But if you find yourself writing same lambda again and again, it's time to convert it to a named function.

### Capture Operator

Well, anonymous functions help us to shorten the code, you can still shorten it further using **capture operator**. We can rewrite our _multiply function_ as below using capture operator.

```elixir
iex> multiply = &(&1 * &2 * &3)
#Function<40.3316493/3 in :erl_eval.expr/6>
```

It's just that you enclose your function with `&()` and just focus on parameters. What if you have just two parameters with `*` operator?

```elixir
iex> multiply = &(&1 * &2)
&:erlang.*/2
```

Focus **&:erlang.\*/2** :points_up:. Elixir (or Erlang) didn't create new function for us but just rebound the existing `*` operator function to our variable **multiply**. This is true for all existing functions in Erlang.

But can you skip the number?

```elixir
iex> multiply = &(&1 * &3)
** (CompileError) iex:3: capture argument &3 cannot be defined without &2 (you cannot skip arguments, all arguments must be numbered)
```

It's not that you always need to use `&()` paranthesis. You can use other delimeters as well. But the resuls would be based on the delimeter. For example, if you need to create list, you can create your own funciton like below.

```elixir
iex> create_list = &[&1, &2, &3]
#Function<40.3316493/3 in :erl_eval.expr/6>

iex> create_list.(1, 2, 3)
[1, 2, 3]
```

You might think what value the capture operator is adding apart from reducing the syntax characters. The main idea about this operator is that if you recall, unlike anonymous functions, you cannot pass named functions as parameters to other functions. To make that happen, you can capture complete named function into a variable.

```elixir
iex> multiplyFunc = &OurMatModule.multiply/2
&OurMatModule.multiply/2

iex> multiplyFunc.(1, 2)
2
```

## Default Parameter Values

If you are an experienced developer, you might have noticed little redundancy in above code snippets. You can replace below code

```elixir
defmodule OurMathModule do
    def multiply(num) do
       num * num
    end

    def multiply(num1, num2) do
        num1 * num2
    end
end
```

with

```elixir
defmodule OurMathModule do
    def multiply(num) do
       multiply(num, num)
    end

    def multiply(num1, num2) do
        num1 * num2
    end
end
```

It seems this is obvious. Yes, it is. But often writing more functions in the code we do forget that we can compose functions with other functions. Why did I bring this topic? Because Elixir does this internally when you use **default values**.

To provide a default value to a function, you can use `\\` syntax.

```elixir
def multiply(num1, num2 // 5) do
    num1 * num2
end
```

If you call `multiply(5)`, you will get `25`. If you do pass second parameter, it will pick up that value. Again this is common in every language. But there is one thing where Elixir shines.

Let's have one more parameter `num3`.

```elixir
def multiply(num1, num2 // 5, num3) do
    num1 * num2 * num3
end
```

What would happen if you call the function with only two arguments? Which parameter will receive the second argument? `num2` or `num3`?

```elixir
iex> multiply(3, 4)
60
```

::bonus{noOfStars = 5}
Elixir will **pick** the _mandatory_ parameters first from the argument list. So, in our case, argument `4` will be given to `num3` as `num2` already has a default value. This is possible because Elixir generates two defintions - `multiply/2` and `multiply/3` - automatically. And when you call `multiply/2`, it calls `multiply/3` with default value.

Unlike other languages, you can have default values at any position in Elixir.
::

## Private Functions

As named functions need to be defined inside a module, by default all functions are **public** and they can be called from other modules. Sometimes, we might need to restrict that. And for this we have **private** function which you can define it using `defp` keyword.

```elixir
defmodule OurMathModule do
    def square(num) do
       multiply(num, num)
    end

    defp multiply(num1, num2) do
        num1 * num2
    end
end
```

As per my experience so far, it is bettter to use private functions as much as possible and only expose them as needed. Why? It will make you a good programmer as you will start thinking about **least access** principle.

## Function and Module Naming Conventions

## Using Functions from Another Module

## Importing Entire Modules

### Importing Specific Functions from a Module

### Other Ways of Importing

## Module Attributes

---

## Pattern Matching

### Multiclause Functions

### Guards

### Multiclause Lambdas

## Conditionals

### Branching with Multiclause Functions

### Classical

### Branching Constants

### With

```

```

```

```
